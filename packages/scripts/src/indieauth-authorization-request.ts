import crypto from 'node:crypto'
import { fileURLToPath } from 'node:url'
import { parseArgs } from 'node:util'
import canonicalUrl from '@jackdbd/canonical-url'
import {
  authorizationRequestUrl,
  metadataEndpoint,
  serverMetadata
} from '@jackdbd/indieauth'
import { exitOne } from '@repo/stdlib'
import {
  CLIENT_ID_NONEXISTENT,
  CODE_VERIFIER_LENGTH,
  ME,
  REDIRECT_URI_NONEXISTENT
} from '@repo/stdlib/test-utils'

const __filename = fileURLToPath(import.meta.url)
const prefix = `[${__filename}] `

const run = async () => {
  const { values } = parseArgs({
    allowPositionals: false,
    options: {
      'code-verifier-length': {
        type: 'string',
        default: String(CODE_VERIFIER_LENGTH)
      },
      'client-id': { type: 'string', default: CLIENT_ID_NONEXISTENT },
      me: { type: 'string', default: ME },
      'redirect-uri': { type: 'string', default: REDIRECT_URI_NONEXISTENT },
      verbose: { type: 'boolean' }
    }
  })

  if (values.verbose) {
    console.log(`${prefix}ensuring given profile URL is a canonical URL`)
  }

  const me = canonicalUrl(values.me!)
  const client_id = values['client-id']!
  const redirect_uri = values['redirect-uri']!
  const code_verifier_length = parseInt(values['code-verifier-length']!)

  const { value: metadata_endpoint } = await metadataEndpoint(me)

  if (!metadata_endpoint) {
    exitOne(`${prefix}metadata_endpoint not available in server metadata`)
    return
  }

  const { value: metadata } = await serverMetadata(metadata_endpoint)

  if (!metadata) {
    exitOne(`${prefix}server metadata is not available`)
    return
  }

  const {
    authorization_endpoint,
    code_challenge_methods_supported,
    scopes_supported
  } = metadata

  if (!code_challenge_methods_supported) {
    exitOne(
      `${prefix}code_challenge_methods_supported not available in server metadata`
    )
    return
  }

  const code_challenge_method = code_challenge_methods_supported[0]!

  if (!scopes_supported) {
    exitOne(`${prefix}scopes_supported not available in server metadata`)
    return
  }

  // shuffle the array and pick the first 4 scopes
  const scopes = scopes_supported.sort(() => 0.5 - Math.random()).slice(0, 4)
  console.log('scopes (chosen by the user)', scopes)

  const state = crypto.randomBytes(12).toString('hex')
  console.log('state (generated by the client)', state)

  const auth = authorizationRequestUrl({
    authorization_endpoint,
    client_id,
    code_challenge_method,
    code_verifier_length,
    me,
    redirect_uri,
    scopes,
    state
  })

  console.log(`request to the authorization endpoint ${authorization_endpoint}`)
  console.log(auth)
}

run()
