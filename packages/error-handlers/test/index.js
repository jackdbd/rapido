import { describe, it, before, after } from 'node:test'
import Fastify from 'fastify'
import fastifyCookie from '@fastify/cookie'
import fastifyCsrf from '@fastify/csrf-protection'
import { error_response } from '@jackdbd/indieauth/schemas'
import {
  InvalidRequestError,
  TemporaryUnavailableError
} from '@jackdbd/oauth2-error-responses'
import { Type } from '@sinclair/typebox'
import { defErrorHandler } from '../lib/index.js'

const GREET_PATTERN = '^hello [a-z]{3}$'

const ERROR_DESCRIPTION = {
  invalid_state:
    'The state parameter generated by the server does not match the one sent by the client.',
  500: 'We encountered an unknown error. Please try again later.',
  503: 'Down for maintenance. We will be back online soon.'
}

const ERROR_URI = {
  invalid_state:
    'https://developer.mozilla.org/en-US/docs/Web/Security/Practical_implementation_guides/CSRF_prevention',
  500: 'https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500',
  503: 'https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503'
}

const fastifyInstance = () => {
  const fastify = Fastify()
  fastify.register(fastifyCookie)
  fastify.register(fastifyCsrf)

  fastify.get('/exception', async (_request, _reply) => {
    throw new Error(ERROR_DESCRIPTION[500])
  })

  fastify.get('/not-available', async (_request, _reply) => {
    throw new TemporaryUnavailableError({
      error_description: ERROR_DESCRIPTION[503],
      error_uri: ERROR_URI[503]
    })
  })

  fastify.get('/throw-invalid-state', async (_request, reply) => {
    throw new InvalidRequestError({
      error_description: ERROR_DESCRIPTION.invalid_state,
      error_uri: ERROR_URI.invalid_state,
      state: reply.generateCsrf()
    })
  })

  fastify.get('/reply-invalid-state', async (_request, reply) => {
    const err = new InvalidRequestError({
      error_description: ERROR_DESCRIPTION.invalid_state,
      error_uri: ERROR_URI.invalid_state,
      state: reply.generateCsrf()
    })
    return reply
      .code(err.statusCode)
      .send(err.payload({ include_error_description: true }))
  })

  fastify.post(
    '/request-body-has-schema',
    {
      schema: {
        body: Type.Object({
          color: Type.Union([
            Type.Literal('red'),
            Type.Literal('green'),
            Type.Literal('blue')
          ]),
          country_code: Type.String({ minLength: 2, maxLength: 2 }),
          grade: Type.Number({ minimum: 1, maximum: 10 }),
          greet: Type.Optional(Type.String({ pattern: GREET_PATTERN })),
          tuple: Type.Tuple([
            Type.String({ minLength: 2 }),
            Type.Number({ minimum: 5 })
          ]),
          website: Type.String({ format: 'uri' })
        }),
        response: {
          '4xx': error_response,
          '5xx': error_response
        }
      }
    },
    async (_request, reply) => {
      return reply.send({ passed_validation: true })
    }
  )

  return fastify
}

describe('Production error handler configuration', () => {
  it('does not include error_description by default', async (t) => {
    const fastify = fastifyInstance()
    fastify.setErrorHandler(defErrorHandler())

    const response = await fastify.inject({ method: 'GET', url: '/exception' })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 500)
    t.assert.strictEqual(res.error, 'server_error')
    t.assert.strictEqual(res.error_description, undefined)
  })

  it('includes error_description when the option `includeErrorDescription` is set to true', async (t) => {
    const fastify = fastifyInstance()
    fastify.setErrorHandler(defErrorHandler({ includeErrorDescription: true }))

    const response = await fastify.inject({ method: 'GET', url: '/exception' })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 500)
    t.assert.strictEqual(res.error, 'server_error')
    t.assert.strictEqual(res.error_description, ERROR_DESCRIPTION[500])
  })
})

describe('JSON response to POST request that does not pass schema validation (client error)', () => {
  let fastify
  before(() => {
    fastify = fastifyInstance()
    fastify.setErrorHandler(defErrorHandler({ includeErrorDescription: true }))
  })

  after(async () => {
    await fastify.close()
  })

  it('has error=invalid_request and an error_description that mentions a missing required property', async (t) => {
    const url = '/request-body-has-schema'
    const body = {}

    const response = await fastify.inject({ method: 'POST', url, body })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(
      res.error_description,
      `body must have required property 'color'`
    )
  })

  it('has error=invalid_request and an error_description that mentions all allowed values for a constant', async (t) => {
    const url = '/request-body-has-schema'
    const body = {
      color: 'pink',
      country_code: 'IT',
      grade: 8,
      tuple: ['hi', 5],
      website: 'https://example.com/'
    }

    const response = await fastify.inject({ method: 'POST', url, body })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(
      res.error_description,
      `body/color must be equal to constant (allowed values: red, green, blue)`
    )
  })

  it('has error=invalid_request and an error_description that mentions that a string is not of the required minimum length', async (t) => {
    const url = '/request-body-has-schema'
    const body = {
      color: 'red',
      country_code: 'ITA',
      grade: 8,
      tuple: ['hi', 5],
      website: 'https://example.com/'
    }

    const response = await fastify.inject({ method: 'POST', url, body })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(
      res.error_description,
      `body/country_code must NOT have more than 2 characters`
    )
  })

  it('has error=invalid_request and an error_description that mentions that a number does not satify a constraint', async (t) => {
    const url = '/request-body-has-schema'
    const body = {
      color: 'red',
      country_code: 'IT',
      grade: 18,
      tuple: ['hi', 5],
      website: 'https://example.com/'
    }

    const response = await fastify.inject({ method: 'POST', url, body })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(res.error_description, `body/grade must be <= 10`)
  })

  it('has error=invalid_request and an error_description that mentions that a string does not match the required format', async (t) => {
    const url = '/request-body-has-schema'
    const body = {
      color: 'red',
      country_code: 'IT',
      grade: 8,
      tuple: ['hi', 5],
      website: 'foo'
    }

    const response = await fastify.inject({ method: 'POST', url, body })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(
      res.error_description,
      `body/website must match format "uri"`
    )
  })

  it('has error=invalid_request and an error_description that mentions that a string does not match the required pattern', async (t) => {
    const url = '/request-body-has-schema'
    const body = {
      color: 'red',
      country_code: 'IT',
      grade: 8,
      greet: 'hi',
      tuple: ['hi', 5],
      website: 'https://example.com/'
    }

    const response = await fastify.inject({ method: 'POST', url, body })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(
      res.error_description,
      `body/greet must match pattern "${GREET_PATTERN}"`
    )
  })
})

describe('JSON response when there is a client error in the request handler (4xx)', () => {
  let fastify
  before(() => {
    fastify = fastifyInstance()
    fastify.setErrorHandler(defErrorHandler({ includeErrorDescription: true }))
  })

  after(async () => {
    await fastify.close()
  })

  it('includes error_description and state, when there is an error regarding the state parameter (request handler throws)', async (t) => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/throw-invalid-state'
    })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(res.error_description, ERROR_DESCRIPTION.invalid_state)
  })

  it('includes error_description and state, when there is an error regarding the state parameter (request handler replies)', async (t) => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/reply-invalid-state'
    })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 400)
    t.assert.strictEqual(res.error, 'invalid_request')
    t.assert.strictEqual(res.error_description, ERROR_DESCRIPTION.invalid_state)
  })
})

describe('JSON response when there is a server error (5xx)', () => {
  let fastify
  before(() => {
    fastify = fastifyInstance()
    fastify.setErrorHandler(defErrorHandler({ includeErrorDescription: true }))
  })

  after(async () => {
    await fastify.close()
  })

  it('includes error_description when there is an internal server error (500)', async (t) => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/exception'
    })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 500)
    t.assert.strictEqual(res.error, 'server_error')
    t.assert.strictEqual(res.error_description, ERROR_DESCRIPTION[500])
  })

  it('includes error_description when the service is not available (503)', async (t) => {
    const response = await fastify.inject({
      method: 'GET',
      url: '/not-available'
    })
    const res = await response.json()

    t.assert.strictEqual(response.statusCode, 503)
    t.assert.strictEqual(res.error, 'temporarily_unavailable')
    t.assert.strictEqual(res.error_description, ERROR_DESCRIPTION[503])
    t.assert.strictEqual(res.error_uri, ERROR_URI[503])
  })
})
